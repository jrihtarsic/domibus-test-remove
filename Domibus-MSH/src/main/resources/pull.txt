Pull request mechanism
    TX1:
        LOOP locks
            TX2:
	    	    lock messaging_lock
	    	    retrieve message_id
	    	    delete lock
	    	    retrieve status

	    	    EXCEPTION: (The main raison would be that the message is already locked)
	    	        Loop continues
	    	        lock not delete

        if !has_attempt_left
    	    delete raw_reccord
    	    change status send_failure
    	    notify send_failure
    	    continue loop
        else
    	    if !first_attempt
    		    delete raw_reccord
    	    endif
    	send message
    	    TX3
    		    increase attempt number
    		    IF waiting_for_callback
    		    	if has attempt left
    		    		increase attemp date.
    		    	else
    		    		delete raw reccord.(Not needed, It will be deleted on the next pull.The message has not attempt left but still waiting for potential receipt.)
    		    	change status waiting for receipt.
    		    	notify	waiting for receipt.
    		    	FINNALY:
    		    	    TX4
                            create lock
    		    ELSE IF pulled_failed
    		    	delete raw_reccord. (This causes a problem we should have job that clear those raw reccords when the message is in final status).
    		    	if has attempt left
    		    		increase attemp date.
    		    		change status ready to pull.
    		    		notify	ready to pull.
    		    		FINNALY:
    		    		    TX4
    		    		        create lock
    		    	else
    		    		change status send_failure.
    		    		notify	send_failure.
    		    	end if
    		    END iF

        end if

Receipt mechanism.
	TX1:
	    TX2:
	        lock
	        delete lock
	        EXCEPTION:
	            return signal mess to long to validate message.
	    TX3:
	        if ok
		        change status acknowledge.
		        notify acknowledge.
		    end if
	        if PULL_FAILED
		        delete raw_reccord.
		        if attempt left
		    	    just keep the lock attempts should have been incremented already.
		    	    change status ready to pull.
		    	    notify	ready to pull.
		    	    finally:
		    	        TX4:create LOCK
		    	end if
		        else
		        	change status send_failure.
		        	notify	send_failure.
		        end

Retry mechanism
TX1:
    Select messages in waiting fo receipt with next attempt now and lock in the database.
    LOOP:
        TX2:
            select for update
            delete lock
            EXCEPTION:
                continue loop.

            delete raw_reccord
    if has attempt_left
	    if messageLocking not present
	        thow exception: IllegalState
	endif.
	change status to ready_to_pull.

	notify ??
else
	delete lock
	change status to send_failure.
	notify??

Purge mechanisme
	change status to send_failure.
	delete raw_reccord
	notify??



Implement mysql/oracle switch OK
Merge 3.3.4 OK
Do code review OK.
Test on oracle. OK.
correct and write unit test.




Test:

Happy flow Ok mysql Ora ok
With no receipt retry in pull mechanism OK mysql.
With no receipt retry with retry service. Increase the pull time above the next send attempt. Ora ok
With attempt staled. mysql OK ora ok.
Without reception awareness. Bug not possible to load the pmode without receptionAwareness
Test purge.
Resend. Ok oracle.
Under charge. OK mysql
Test retry on pull failed. Oracle OK
Test retry with more attempt and without attempt.
Check the notifications for the retry/purge/retry at pull moment.

create a ticket to explain the unique constraint execption due to acknowledgement send in the same transaction.


